Экземенационное задание «Паттерны проектирования, MVC»
======================================================

**Реализовать систему получения данных из различных источников и отобразить эти данные в парадигме MVC**

Задание состоит из нескольких частей. Каждая часть описана ниже под заголовком «Задача». Также даны примеры приблизительной реализации и их объяснения. Данные для обработки в `src/dataSource`. Используйте для разработки нэймспейс `App`.

Вы можете смотреть и разбирать примеры (нэймспейс `Example`), но **не копируйте** код примеров напрямую. Копирование кода примеров будет отрицательно влиять на итоговый результат.

Вы можете посмотреть на результат работы примера, запустив dev-сервер из каталога приложения:

```shell
php -S 0.0.0.0:8080 -t examples/public
```

-----------------------------------------------------------

Задача
------

Существуют источники данных в виде `csv` и `json`-файлов. Нулевая (самая верхняя) строка `csv`-файла содержит имена полей, `json` — это массив одинаковых по структуре «плоских» объектов, каждый из них также содержит имена полей.

Необходимо реализовать пакет (комплект классов), который будет читать данные из этих источников и предоставлять их в виде программных сущностей (объектов и массивов). Использовать паттерны Repository, Adapter.

Пакет должен предоставлять возможность выборки одной строки (json-объекта) по полю ID и получения заданного количества объектов с заданным смещением (n строк начиная со строки m или n объектов начиная с m от начала). Смещение — необязательный параметр.

Результатом работы поиска по ID должен быть стандартный объект (`\StdClass`) с полями, названными по значениям нулевой строки в случае с `csv` или именам полей `json` и значениями полей с соответствующим ID.

Результатом выборки — `Iterable`-объект (массив) со стандартными объектами внутри.

Входящие условия:

- поля `date`, `birthday`, `issueDate` содержит строку с датой формата `d.m.Y` (или null);
- поле ID всегда содержит число и не может быть пустым;
- объем данных не будет превышать количество оперативной памяти (все данные источника можно прочитать за один раз);

Условия выполнения

- все пустые поля должны интерпретироваться как null;
- при поиске по ID в случае отсутствия запрошенного ID должен возвращаться null;
- при выборке диапазона:
  - если значение смещения больще количества объектов, должно быть брошено исключение;
  - если количество объектов меньше заданного, должно возвратиться максимально доступное количество объектов;


Примерный план выполнения
-------------------------

**Adapter**

Поскольку нам нужно читать данные из разных источников одинаковым способом, необходим интерфейс с методом `connect` (для установки соединения / открытия файла) и методом `getData`, возвращающим данные источника. 

Обе реализации этого интерфейса (для `csv` и `json`) будут открывать целевой файл, читать из него данные и возвращать массив объектов.

Примеры смотрите в каталоге `examples/Adapter`.

**Repository**

Поскольку мы имеем два (или больше) источника данных для системы, репозиторий должен понимать, с каким из источников он будет работать. Поэтому в конструктор репозитория должен передаваться экземпляр источника данных, являющися имплементацией интерфейса адаптера.

Поскольку адаптер всегда возвращает одинаковыую структуру, имеет смысл вынести методы

- `find($id)` для поиска заданного ID,
- `get($number, $offset = 0)` для выборки нужного количества объектов

в абстрактный класс, а в конкретном его выражении оставить только конструктор, в который и передавать соответствующий адаптер.

Смотрите примеры в `examples/Repository/AbstractRepository.php`

-----------------------------------------------------------

Задача
------

DataMapper для репозитория. 

Изменить (расширить) созданный на предыдущем этапе репозиторий так, чтобы он возвращал не стандартный объект (или массив объектов), а экземпляр класса, имя которого передано в конструктор. Предусмотреть ситуацию обратной совместимости — если имя класса не передано, поведение должно остаться прежним, то есть должны возвращаться стандартные объекты. 

Объект должен формироваться с помощью фабрики (реализация — на ваше усмотрение).

Примерный план выполнения
-------------------------

Добавляем в конструктор репозитория параметр `?string $className` и приватный метод `populate`, получающий объект и имя класса. Если передано имя класса, вызываем фабрику для построения заданного объекта.

Класс фабрики в методе `build` (или `make`) из имени целевого класса создаёт ReflectionObject, получает все его свойства, определяет тип каждого (если это возможно), находит имя свойства в исходном объекте и присваивает значение исходного свойства полю целевого класса.

Пример фабрики в `examples/ObjectFactory/Factory.php`    
Пример репозитория для класса `Example\Entity\Vehicle` в `examples/Repository/VehicleRepository.php`

-----------------------------------------------------------

Задача
------

Фабрика для объекта http-запроса, класс для http-ответа, экземпляр приложения (singleton), контроллер.

Создайте класс, который будет обрабатывать http-запрос, получать из него данные, и на основе этих данных (и глобальных переменных php) строить объект, несущий в себе все параметры запроса. Создайте singleton-класс для экземпляра приложения. Экзепляр приложения должен иметь методы для получения объекта запроса и возврата объекта ответа. 

Приложение также должно получать конфигурацию роутинга, по которой будет вычислять, на какой именно контроллер отправляется запрос. Сделайте контроллер, который будет возвращать ответ 404, и контроллер, который будет вызывать и рендерить содержимое шаблона. Сделайте так, чтоб 404-контроллер вызывался приложением по-умолчанию, если в конфигурации роутинга не найдено правило маршрутизации. 

Примерный план выполнения
-------------------------

Создайте класс `Request`, в котором будут свойства для хранения `get`, `post`, `files`, `headers` и других частей запроса. В этом классе должен быть фабричный метод `make`, который будет создавать экземпляр этого класса, забирать из глобальных переменных (`$_GET`, `$_POST`, `$_FILES` и так далее) из значения и присваивать их соответствующим свойствам. Смотрите пример в `examples/Http/Request.php`

Создайте класс `Response`, в котором будут методы для назначения частей ответа — заголовков, тела ответа, и вывода этих частей: `header()` для отправки заголовка, и `echo()` для вывода тела ответа. Пример в `examples/Http/Response.php`

Создайте класс `Application` (не забывайте об основополагающих принципах паттерна Singleton), сделайте в нем методы для обработки экземпляра `Request`, получения и отправки `Response`. Логично сделать метод для обработки запроса так, чтоб он получал и объект запроса, и конфигурацию роутинга. Пример класса — `examples/Http/Application.php`

Конфигурация роутинга должна представлять из себя контейнер (класс), который в методе `get('path')` будет обращатся к методу определенного контроллера, получать от него `Response` и возвращать этот `Response`. Естественно, эта конфигурация должна получить набор контроллеров приложения (в конструкторе или специальном методе), чтобы обращаться к ним. 

В конце концов, в файле `public/index.php`:

- вызовите фабричный метод класса запроса: `$request = Request::create()`,
- загрузите конфигурацию роутинга,
- получите экземпляр приложения: `$app = Application::getInstance()`,
- установите для него конфигурацию роутинга и любые другие параметры, которые вам понадобятся,
- обработайте запрос и получите ответ: `$response = $app->handle($request)`,
- отправьте ответ: `$response->send()`

### ВНИМАНИЕ

Вы **можете** использовать готовые реализации контейнера зависимостей, роутера, классов Request / Response, в виде composer-зависимостей. При этом у вас **должна быть** собственная реализация контроллера.

Все условия (например, 404 страница в ответ на неверный url) при этом должны быть выполнены.

-----------------------------------------------------------

Задача
------

Реализуйте получение данных из обоих источников (`src/dataSource/data.csv` и `src/dataSource/data.json`) в вашем контроллере, выведите эти данные в браузере.

**ИЛИ**

Реализуйте получение данных из обоих источников (`src/dataSource/data.csv` и `src/dataSource/data.json`) в консольном приложении, выведите их в консоль.

Примерный план выполнения
-------------------------

Здесь надо просто соединить все ранее созданные компоненты.

-----------------------------------------------------------

Критерии оценки результата
==========================

Основная ваша задача — создать систему получения данных из различных источников в ваши классы и отобразить её в парадигме MVC. То есть:
 
- если у вас в итоге будет _репозиторий_, из которого можно получить данные в виде конкретных классов (моделей);
- если у вас будет собственный класс, который обрабатывает http-запрос и получает ваши модели (контроллер);
- и будет отображение данных этих моделей с помощью **любого** механизма, работающего как шаблонизатор (вывод переменных внутри текстового или html-контента),

задание будет считаться выполненым. 

**ВАЖНО**

Расположение файлов данных относительно корня проекта будет постоянным, но разным в зависимости от среды выполнения. Иными словами, пути к файлам данных должны быть указаны **один** раз в конфигурации (или при инициализации) приложения.

Ветка `master` в вашем репозитории должна полностью совпадать с репозиторием-источником. Ваша работа — только в ветке `develop`. **Не меняйте** файлы в каталоге `examples`, ваш рабочий каталог — `src`.
